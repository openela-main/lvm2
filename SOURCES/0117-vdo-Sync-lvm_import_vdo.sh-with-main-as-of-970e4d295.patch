From 34255cb85ad476fd5b4ba3f30a53ea3dc084fcbb Mon Sep 17 00:00:00 2001
From: Marian Csontos <mcsontos@redhat.com>
Date: Thu, 7 Sep 2023 15:06:33 +0200
Subject: [PATCH] vdo: Sync lvm_import_vdo.sh with main as of 970e4d295edd.

---
 scripts/lvm_import_vdo.sh | 277 ++++++++++++++++++++++++--------------
 1 file changed, 176 insertions(+), 101 deletions(-)

diff --git a/scripts/lvm_import_vdo.sh b/scripts/lvm_import_vdo.sh
index f0e93075a..7f3f413e9 100755
--- a/scripts/lvm_import_vdo.sh
+++ b/scripts/lvm_import_vdo.sh
@@ -36,6 +36,9 @@ TEMPDIR="${TMPDIR:-/tmp}/$IMPORT_NAME"
 _SAVEPATH=$PATH
 PATH="/sbin:/usr/sbin:/bin:/usr/sbin:$PATH"
 
+# Set of trapped signals
+declare -a SIGNALS=("HUP" "INT" "QUIT" "ABRT" "TERM" "EXIT")
+
 # user may override lvm location by setting LVM_BINARY
 LVM=${LVM_BINARY:-lvm}
 VDO=${VDO_BINARY:-vdo}
@@ -52,7 +55,9 @@ DM_DEV_DIR="${DM_DEV_DIR:-/dev}"
 DM_UUID_PREFIX="${DM_UUID_PREFIX:-}"
 DM_VG_NAME=
 DM_LV_NAME=
+DEFAULT_VDO_CONFIG="/etc/vdoconf.yml" # Default location of vdo's manager config file
 VDO_CONFIG=${VDO_CONFIG:-}   # can be overridden with --vdo-config
+VDO_CONFIG_RESTORE=
 VDOCONF=
 test -n "$VDO_CONFIG" && VDOCONF="-f $VDO_CONFIG"
 
@@ -61,16 +66,17 @@ VGNAME=
 LVNAME=
 DEVMAJOR=0
 DEVMINOR=0
-PROMPTING=""
-USE_VDO_DM_SNAPSHOT=1
+PROMPTING=
+USE_VDO_DM_SNAPSHOT="--yes"
 VDO_DM_SNAPSHOT_NAME=
 VDO_DM_SNAPSHOT_DEVICE=
 VDO_SNAPSHOT_LOOP=
+VDO_INCONSISTENT=
 
 DRY=0
-VERB=""
-FORCE=""
-YES=""
+VERB=
+FORCE=
+YES=
 ABORT_AFTER_VDO_CONVERT=0
 VDO_ALLOCATION_PARAMS=
 
@@ -78,6 +84,25 @@ VDO_ALLOCATION_PARAMS=
 DEFAULT_NAME="vdovg/vdolvol"
 NAME=""
 
+# predefine empty
+vdo_ackThreads=
+vdo_bioRotationInterval=
+vdo_bioThreads=
+vdo_blockMapCacheSize=
+vdo_blockMapPeriod=
+vdo_compression=
+vdo_cpuThreads=
+vdo_deduplication=
+vdo_hashZoneThreads=
+vdo_indexMemory=
+vdo_indexSparse=
+vdo_logicalBlockSize=
+vdo_logicalThreads=
+vdo_maxDiscardSize=
+vdo_physicalThreads=
+vdo_slabSize=
+vdo_writePolicy=
+
 # help message
 tool_usage() {
 	echo "${TOOL}: Utility to convert VDO volume to VDO LV."
@@ -107,7 +132,11 @@ error() {
 	for i in "$@" ;  do
 		echo "$TOOL: $i" >&2
 	done
-	cleanup 1
+	return 1
+}
+
+warn() {
+	echo "$TOOL: WARNING: $i" >&2
 }
 
 dry() {
@@ -120,15 +149,31 @@ dry() {
 }
 
 cleanup() {
-	trap '' 2
+	RC=$?	# Return code + 128  of the last command eg INT=2 + 128 -> 130
 
-	test -n "$VDO_DM_SNAPSHOT_NAME" && { "$DMSETUP" remove "$VDO_DM_SNAPSHOT_NAME" || true ; }
-	test -n "$VDO_SNAPSHOT_LOOP" && { "$LOSETUP" -d "$VDO_SNAPSHOT_LOOP" || true ; }
+	trap '' "${SIGNALS[@]}" # mute trap for all signals to not interrupt cleanup() on any next signal
+
+	[ -z "$PROMPTING" ] || echo "No"
+
+	[ -e "$VDO_CONFIG_RESTORE" ] && { dry cp -a "$VDO_CONFIG_RESTORE" "${VDO_CONFIG:-"$DEFAULT_VDO_CONFIG"}" || true ; }
+
+	if [ -n "$VDO_DM_SNAPSHOT_NAME" ]; then
+		dry "$LVM" vgchange -an --devices "$VDO_DM_SNAPSHOT_DEVICE" "$VGNAME" &>/dev/null || true
+		for i in {1..20} ; do
+			[ "$(dry "$DMSETUP" info --noheading -co open "$VDO_DM_SNAPSHOT_NAME")" = "0" ] && break
+			sleep .1
+		done
+		dry "$DMSETUP" remove "$VDO_DM_SNAPSHOT_NAME" &>/dev/null || true
+	fi
+
+
+	[ -n "$VDO_SNAPSHOT_LOOP" ] && { dry "$LOSETUP" -d "$VDO_SNAPSHOT_LOOP" || true ; }
+
+	[ -z "$VDO_INCONSISTENT" ] || echo "$TOOL: VDO volume import process exited unexpectedly!" >&2
 
-	test -z "$PROMPTING" || echo "No"
 	rm -rf "$TEMPDIR" || true
-	# error exit status for break
-	exit "${1:-1}"
+
+	exit "$RC"
 }
 
 # Create snapshot target like for persistent snapshot with 16KiB chunksize
@@ -143,7 +188,7 @@ snapshot_create_() {
 	# TODO: maybe use ramdisk via 'brd' device ?)
 	"$TRUNCATE" -s 20M "$file"
 	VDO_SNAPSHOT_LOOP=$("$LOSETUP" -f --show "$file")
-	"$DMSETUP" create "$VDO_DM_SNAPSHOT_NAME" -u "${DM_UUID_PREFIX}-${VDO_DM_SNAPSHOT_NAME}-priv" --table "$(snapshot_target_line_ "$1" "$VDO_SNAPSHOT_LOOP")"
+	"$DMSETUP" create "$VDO_DM_SNAPSHOT_NAME" -u "${DM_UUID_PREFIX}${VDO_DM_SNAPSHOT_NAME}-priv" --table "$(snapshot_target_line_ "$1" "$VDO_SNAPSHOT_LOOP")"
 	VDO_DM_SNAPSHOT_DEVICE="$DM_DEV_DIR/mapper/$VDO_DM_SNAPSHOT_NAME"
 	verbose "Snapshot of VDO device $1 created: $VDO_DM_SNAPSHOT_DEVICE."
 }
@@ -158,7 +203,9 @@ snapshot_merge_() {
 		error "ABORTING: Failed to initialize snapshot merge! Origin volume is unchanged."
 	}
 
-	verbose "Merging converted VDO volume..."
+	verbose "Merging converted VDO volume \"$VDO_DM_SNAPSHOT_NAME\"."
+	VDO_INCONSISTENT=1
+
 	# Running merging
 	"$DMSETUP" resume "$VDO_DM_SNAPSHOT_NAME"
 
@@ -166,30 +213,37 @@ snapshot_merge_() {
 
 	# Loop for a while, till the snapshot is merged.
 	# Should be nearly instantaneous.
-        # FIXME: Recovery when something prevents merging is hard
+	# FIXME: Recovery when something prevents merging is hard
 	for i in $(seq 1 20) ; do
 		status=( $("$DMSETUP" status "$VDO_DM_SNAPSHOT_NAME") )
 		# Check if merging is finished
-		test "${status[3]%/*}" = "${status[4]}" && break
+		[ "${status[3]%/*}" = "${status[4]}" ] && break
 		# Wait a bit and retry
 		sleep .2
 	done
-	test "${status[3]%/*}" = "${status[4]}" || {
+
+	if [ "${status[3]%/*}" != "${status[4]}" ]; then
 		# FIXME: Now what shall we do ??? Help....
-		# Keep snapshot in table for possible analysis...
+		# Keep snapshot in DM table for possible analysis...
 		VDO_DM_SNAPSHOT_NAME=
 		VDO_SNAPSHOT_LOOP=
-		echo "Initial snapshot status ${initial_status[*]}"
-		echo "Failing merge snapshot status ${status[*]}"
+		echo "$TOOL: Initial snapshot status ${initial_status[*]}"
+		echo "$TOOL: Failing merge snapshot status ${status[*]}"
 		error "ABORTING: Snapshot failed to merge! (Administrator required...)"
-	}
-	sync
+	fi
+
+	VDO_INCONSISTENT=
+	VDO_CONFIG_RESTORE=
+
+	verbose "Converted VDO volume is merged to \"$1\"."
+
 	"$DMSETUP" remove "$VDO_DM_SNAPSHOT_NAME" || {
 		sleep 1 # sleep and retry once more
 		"$DMSETUP" remove "$VDO_DM_SNAPSHOT_NAME" || {
 			error "ABORTING: Cannot remove snapshot $VDO_DM_SNAPSHOT_NAME! (check volume autoactivation...)"
 		}
 	}
+
 	VDO_DM_SNAPSHOT_NAME=
 	"$LOSETUP" -d "$VDO_SNAPSHOT_LOOP"
 	VDO_SNAPSHOT_LOOP=
@@ -222,9 +276,9 @@ get_largest_extent_size_() {
 
 	for i in 8 16 32 64 128 256 512 1024 2048 4096 ; do
 		d=$(( $1 / i ))
-		test $(( d * i )) -eq "$1" || break
+		[ $(( d * i )) -eq "$1" ] || break
 		d=$(( $2 / i ))
-		test $(( d * i )) -eq "$2" || break
+		[ $(( d * i )) -eq "$2" ] || break
 		max=$i
 	done
 	echo "$max"
@@ -239,7 +293,7 @@ detect_lv_() {
 
 	DEVICE=${1/#"${DM_DEV_DIR}/"/}
 	DEVICE=$("$READLINK" $READLINK_E "$DM_DEV_DIR/$DEVICE" || true)
-	test -n "$DEVICE" || error "Readlink cannot access device \"$1\"."
+	[ -n "$DEVICE" ] || error "Readlink cannot access device \"$1\"."
 	RDEVICE=$DEVICE
 	case "$RDEVICE" in
 	  # hardcoded /dev  since udev does not create these entries elsewhere
@@ -251,12 +305,12 @@ detect_lv_() {
 		;;
 	  *)
 		RSTAT=$("$STAT" --format "DEVMAJOR=\$((0x%t)) DEVMINOR=\$((0x%T))" "$RDEVICE" || true)
-		test -n "$RSTAT" || error "Cannot get major:minor for \"$DEVICE\"."
+		[ -n "$RSTAT" ] || error "Cannot get major:minor for \"$DEVICE\"."
 		eval "$RSTAT"
 		;;
 	esac
 
-	test "$DEVMAJOR" != "$(grep device-mapper /proc/devices | cut -f1 -d' ')" && return
+	[ "$DEVMAJOR" != "$(grep device-mapper /proc/devices | cut -f1 -d' ')" ] && return
 
 	DEV="$("$DMSETUP" info -c -j "$DEVMAJOR" -m "$DEVMINOR" -o uuid,name --noheadings --nameprefixes --separator ' ')"
 	case "$DEV" in
@@ -332,9 +386,10 @@ convert_lv_() {
 	vg_extent_size=$("$LVM" vgs -o vg_extent_size --units b --nosuffix --noheadings "$VGNAME")
 	vg_extent_size=$(( vg_extent_size / 1024 ))
 
-	test "$vg_extent_size" -le "$extent_size" || {
+	[ "$vg_extent_size" -le "$extent_size" ] || {
 		error "Please vgchange extent_size to at most $extent_size KiB or extend and align virtual size of VDO device on $vg_extent_size KiB before retrying conversion."
 	}
+
 	verbose "Renaming existing LV to be used as _vdata volume for VDO pool LV."
 	dry "$LVM" lvrename $YES $VERB "$VGNAME/$DM_LV_NAME" "$VGNAME/${LVNAME}_vpool" || {
 		error "Rename of LV \"$VGNAME/$DM_LV_NAME\" failed, while VDO header has been already moved!"
@@ -362,19 +417,39 @@ convert_non_lv_() {
 	local output
 	local pvfree
 
-	if [ "$USE_VDO_DM_SNAPSHOT" = "1" ]; then
+	if [ -n "$USE_VDO_DM_SNAPSHOT" ]; then
 		dry snapshot_create_ "$DEVICE"
-		sed "s:$DEVICE:$VDO_DM_SNAPSHOT_DEVICE:" "$TEMPDIR/vdoconf.yml" > "$TEMPDIR/vdo_snap.yml"
+		sed "s|$DEVICE|$VDO_DM_SNAPSHOT_DEVICE|" "$TEMPDIR/vdoconf.yml" > "$TEMPDIR/vdo_snap.yml"
+		# In case of error in the middle of conversion restore original config file
+		VDO_CONFIG_RESTORE="$TEMPDIR/vdoconf.yml"
 		# Let VDO manager operate on snapshot volume
-		VDOCONF="-f $TEMPDIR/vdo_snap.yml"
+		dry cp -a "$TEMPDIR/vdo_snap.yml" "${VDO_CONFIG:-"$DEFAULT_VDO_CONFIG"}"
+	else
+		# If error in the following section, report possible problems ahead
+		VDO_INCONSISTENT=1
 	fi
 
-	verbose "Moving VDO header."
-	output=$(dry "$VDO" convert $VDOCONF $VERB --force --name "$VDONAME")
+	# In case we operate with snapshot, all lvm2 operation will also run on top of snapshot
+	local device=${VDO_DM_SNAPSHOT_DEVICE:-$DEVICE}
+
+	# Check if there is not already an existing PV header, this would have fail on pvcreate after conversion
+	"$LVM" pvs --devices "$device" "$device" 2>/dev/null && {
+		error "Cannot convert volume \"$DEVICE\" with existing PV header."
+	}
+
+	verbose "Moving VDO header on \"$device\"."
 
-	if [ "$ABORT_AFTER_VDO_CONVERT" != "0" ] ; then
-		verbose "Aborting VDO conversion after moving VDO header, volume is useless!"
-		cleanup 0
+	output=$(dry "$VDO" convert $VDOCONF $VERB --force --name "$VDONAME" 2>&1) || {
+		local rc=$?
+		echo "$output"
+		error "Failed to convert VDO volume \"$DEVICE\" (exit code $rc)."
+	}
+
+	echo "$output"
+
+	if [ "$ABORT_AFTER_VDO_CONVERT" != "0" ]; then
+		warn "Aborting VDO conversion after moving VDO header, volume is useless!"
+		return 0
 	fi
 
 	# Parse result from VDO preparation/conversion tool
@@ -399,12 +474,7 @@ convert_non_lv_() {
 		esac
 	done <<< "$output"
 
-	# In case we operation with snapshot, all lvm2 operation will also run on top of snapshot
-	local devices=${VDO_DM_SNAPSHOT_DEVICE:-$DEVICE}
-
-	dry "$LVM" pvcreate $YES --devices "$devices" --dataalignment "$vdo_offset"b "$devices" || {
-		error "Creation of PV on \"$DEVICE\" failed, while VDO header has been already moved!"
-	}
+	dry "$LVM" pvcreate $YES $VERB $FORCE --devices "$device" --dataalignment "$vdo_offset"b "$device"
 
 	# Obtain free space in this new PV
 	# after 'vdo convert' call there is ~(1-2)M free space at the front of the device
@@ -421,47 +491,53 @@ convert_non_lv_() {
 	# To precisely byte-synchronize the size of VDO LV, user can lvresize such VDO LV later.
 	vdo_logicalSizeRounded=$(( ( vdo_logicalSize / extent_size ) * extent_size ))
 
-	verbose "Creating VG \"${NAME%/*}\" with extent size $extent_size KiB."
-	dry "$LVM" vgcreate $YES $VERB --devices "$devices" -s "${extent_size}k" "$VGNAME" "$devices" || {
-		error "Creation of VG \"$VGNAME\" failed, while VDO header has been already moved!"
-	}
+	verbose "Creating volume group \"$VGNAME\" with the extent size $extent_size KiB."
+	dry "$LVM" vgcreate $YES $VERB --devices "$device" -s "${extent_size}k" "$VGNAME" "$device"
 
-	verbose "Creating VDO pool data LV from all extents in volume group $VGNAME."
-	dry "$LVM" lvcreate -Zn -Wn -an $YES $VERB --devices "$devices" -l100%VG -n "${LVNAME}_vpool" "$VGNAME" "$devices"
+	verbose "Creating VDO pool data LV from all extents in the volume group \"$VGNAME\"."
+	dry "$LVM" lvcreate -Zn -Wn -an $YES $VERB --devices "$device" -l100%VG -n "${LVNAME}_vpool" "$VGNAME" "$device"
 
 	verbose "Converting to VDO pool."
-	dry "$LVM" lvconvert $YES $VERB $FORCE --devices "$devices" --config "$VDO_ALLOCATION_PARAMS" -Zn -V "${vdo_logicalSizeRounded}k" -n "$LVNAME" --type vdo-pool "$VGNAME/${LVNAME}_vpool"
-	if [ "$vdo_logicalSizeRounded" -lt "$vdo_logicalSize" ] ; then
+	dry "$LVM" lvconvert ${USE_VDO_DM_SNAPSHOT:-"$YES"} $VERB $FORCE --devices "$device" --config "$VDO_ALLOCATION_PARAMS" -Zn -V "${vdo_logicalSizeRounded}k" -n "$LVNAME" --type vdo-pool "$VGNAME/${LVNAME}_vpool"
+
+	if [ "$vdo_logicalSizeRounded" -lt "$vdo_logicalSize" ]; then
 		# need to extend virtual size to be covering all the converted area
 		# let lvm2 to round to the proper virtual size of VDO LV
-		dry "$LVM" lvextend $YES $VERB --fs ignore --devices "$devices" -L "$vdo_logicalSize"k "$VGNAME/$LVNAME"
+		dry "$LVM" lvextend $YES $VERB --devices "$device" -L "$vdo_logicalSize"k "$VGNAME/$LVNAME"
 	fi
 
-	dry "$LVM" vgchange -an $VERB $FORCE --devices "$devices" "$VGNAME"
-
-	if [ "$USE_VDO_DM_SNAPSHOT" = "1" ]; then
-		if [ -z "$YES" ]; then
-			PROMPTING=yes
-			echo "Warning: Do not interrupt merging process once it starts (VDO data may become irrecoverable)!"
-			echo -n "Do you want to merge converted VDO device \"$DEVICE\" to VDO LV \"$VGNAME/$LVNAME\"? [y|N]: "
-			read -r -n 1 -s ANSWER
-			case "${ANSWER:0:1}" in
-			  y|Y )  echo "Yes" ;;
-			    * )  echo "No" ; PROMPTING=""; cleanup 1 ;;
-			esac
-			PROMPTING=""
-			YES="-y" # From now, now prompting
-		fi
+	VDO_INCONSISTENT=
 
-		dry snapshot_merge_ "$DEVICE"
-		if [ -e "$TEMPDIR/vdo_snap.yml" ]; then
-			dry cp "$TEMPDIR/vdo_snap.yml" "$VDO_CONFIG"
-		else
-			dry rm -f "$VDO_CONFIG"
-		fi
-		verbose "Merging of VDO device finished."
+	[ -z "$USE_VDO_DM_SNAPSHOT" ] && return # no-snapshot case finished
+
+	dry "$LVM" vgchange -an $VERB $FORCE --devices "$device" "$VGNAME"
+
+	# Prevent unwanted auto activation when VG is merged
+	dry "$LVM" vgchange --setautoactivation n $VERB $FORCE --devices "$device" "$VGNAME"
+
+	if [ -z "$YES" ]; then
+		PROMPTING=yes
+		warn "Do not interrupt merging process once it starts (VDO data may become irrecoverable)!"
+		echo -n "$TOOL: Do you want to merge converted VDO device \"$DEVICE\" to VDO LV \"$VGNAME/$LVNAME\"? [y|N]: "
+		read -r -n 1 -s ANSWER
+		case "${ANSWER:0:1}" in
+		  y|Y )  echo "Yes" ;;
+		    * )  echo "No" ; PROMPTING=""; return 1 ;;
+		esac
+		PROMPTING=""
+		YES="-y" # From now, now prompting
 	fi
 
+	dry snapshot_merge_ "$DEVICE"
+
+	# For systems using devicesfile add 'merged' PV into system.devices.
+	# Bypassing use of --valuesonly to keep compatibility with older lvm.
+	local usedev=$("$LVM" lvmconfig --typeconfig full devices/use_devicesfile || true)
+	[ "${usedev#*=}" = "1" ] && dry "$LVM" lvmdevices --adddev "$DEVICE"
+
+	# Restore auto activation for a VG
+	dry "$LVM" vgchange --setautoactivation y $VERB $FORCE "$VGNAME"
+
 	dry "$LVM" lvchange -ay $VERB $FORCE "$VGNAME/$LVNAME"
 }
 
@@ -479,43 +555,43 @@ convert2lvm_() {
 	detect_lv_ "$DEVICE"
 	case "$DM_UUID" in
 		LVM-*)	eval "$("$DMSETUP" splitname --nameprefixes --noheadings --separator ' ' "$DM_NAME")"
-			if [ -z "$VGNAME" ] || [ "$VGNAME" = "$LVNAME" ] ; then
+			if [ -z "$VGNAME" ] || [ "$VGNAME" = "$LVNAME" ]; then
 				VGNAME=$DM_VG_NAME
 				verbose "Using existing volume group name \"$VGNAME\"."
-				test -n "$LVNAME" || LVNAME=$DM_LV_NAME
+				[ -n "$LVNAME" ] || LVNAME=$DM_LV_NAME
 			elif [ "$VGNAME" != "$DM_VG_NAME" ]; then
 				error "Volume group name \"$VGNAME\" does not match name \"$DM_VG_NAME\" for VDO device \"$DEVICE\"."
 			fi
 			;;
 		*)
 			# Check if we need to generate unused $VGNANE
-			if [ -z "$VGNAME" ] || [ "$VGNAME" = "$LVNAME" ] ; then
+			if [ -z "$VGNAME" ] || [ "$VGNAME" = "$LVNAME" ]; then
 				VGNAME=${DEFAULT_NAME%/*}
 				# Find largest matching VG name to our 'default' vgname
-				LASTVGNAME=$(LC_ALL=C "$LVM" vgs -oname -O-name --noheadings -S name=~"${VGNAME}" | grep -E "${VGNAME}[0-9]? ?" | head -1 || true)
+				LASTVGNAME=$(LC_ALL=C "$LVM" vgs -oname -O-name --noheadings -S name=~"${VGNAME}" | grep -m 1 -E "${VGNAME}[0-9]? ?" || true)
 				if [ -n "$LASTVGNAME" ]; then
 					LASTVGNAME=${LASTVGNAME#*"${VGNAME}"}
 					# If the number is becoming too high, try some random number
-					test "$LASTVGNAME" -gt 99999999 2>/dev/null && LASTVGNAME=$RANDOM
+					[ -n "$LASTVGNAME" ] && [ "$LASTVGNAME" -gt 99999999 ] && LASTVGNAME=$RANDOM
 					# Generate new unused VG name
 					VGNAME="${VGNAME}$(( LASTVGNAME + 1 ))"
 					verbose "Selected unused volume group name \"$VGNAME\"."
 				fi
 			fi
 			# New VG is created, LV name should be always unused.
-			test -n "$LVNAME" || LVNAME=${DEFAULT_NAME#*/}
+			[ -n "$LVNAME" ] || LVNAME=${DEFAULT_NAME#*/}
 			"$LVM" vgs "$VGNAME" >/dev/null 2>&1 && error "Cannot use already existing volume group name \"$VGNAME\"."
 			;;
 	esac
 
 	verbose "Checked whether device \"$DEVICE\" is already logical volume."
 
-	"$MKDIR" -p -m 0000 "$TEMPDIR" || error "Failed to create $TEMPDIR."
+	"$MKDIR" -p -m 0000 "$TEMPDIR" || error "Failed to create \"$TEMPDIR\"."
 
 	# TODO: might use directly  /etc/vdoconf.yml (avoiding need of 'vdo' manager)
 	verbose "Getting YAML VDO configuration."
 	"$VDO" printConfigFile $VDOCONF >"$TEMPDIR/vdoconf.yml"
-	test -s "$TEMPDIR/vdoconf.yml" || error "Cannot work without VDO configuration"
+	[ -s "$TEMPDIR/vdoconf.yml" ] || error "Cannot work without VDO configuration."
 
 	# Check list of devices in VDO configure file for their major:minor
 	# and match with given $DEVICE devmajor:devminor
@@ -524,13 +600,13 @@ convert2lvm_() {
 		DEV=$("$READLINK" $READLINK_E "$i") || continue
 		RSTAT=$("$STAT" --format "MAJOR=\$((0x%t)) MINOR=\$((0x%T))" "$DEV" 2>/dev/null) || continue
 		eval "$RSTAT"
-		test "$MAJOR" = "$DEVMAJOR" && test "$MINOR" = "$DEVMINOR" && {
-			test -z "$FOUND" || error "VDO configuration contains duplicate entries $FOUND and $i"
+		if [ "$MAJOR" = "$DEVMAJOR" ] && [ "$MINOR" = "$DEVMINOR" ]; then
+			[ -z "$FOUND" ] || error "VDO configuration contains duplicate entries $FOUND and $i."
 			FOUND=$i
-		}
+		fi
 	done
 
-	test -n "$FOUND" || error "Can't find matching device in VDO configuration file."
+	[ -n "$FOUND" ] || error "Can't find matching device in VDO configuration file."
 	verbose "Found matching device $FOUND  $MAJOR:$MINOR."
 
 	VDONAME=$(awk -v DNAME="$FOUND" '/.*VDOService$/ {VNAME=substr($1, 0, length($1) - 1)} /[[:space:]]*device:/ { if ($2 ~ DNAME) {print VNAME}}' "$TEMPDIR/vdoconf.yml")
@@ -541,7 +617,7 @@ convert2lvm_() {
 	case "$DM_OPEN" in
 	Device*) ;; # no devices
 	*)	eval "$DM_OPEN"
-		test "${DM_OPEN:-0}" -eq 0 || error "Cannot convert in use VDO volume \"$VDONAME\"!"
+		[ "${DM_OPEN:-0}" -eq 0 ] || error "Cannot convert in use VDO volume \"$VDONAME\"!"
 		;;
 	esac
 
@@ -583,21 +659,22 @@ EOF
 	dry "$VDO" stop $VDOCONF --name "$VDONAME" $VERB
 
 	# If user has not provided '--yes', prompt before conversion
-	if [ -z "$YES" ] && [ "$USE_VDO_DM_SNAPSHOT" != "1" ]; then
+	if [ -z "$YES" ] && [ -z "$USE_VDO_DM_SNAPSHOT" ]; then
 		PROMPTING=yes
-		echo -n "Convert VDO device \"$DEVICE\" to VDO LV \"$VGNAME/$LVNAME\"? [y|N]: "
+		echo -n "$TOOL: Convert VDO device \"$DEVICE\" to VDO LV \"$VGNAME/$LVNAME\"? [y|N]: "
 		read -r -n 1 -s ANSWER
 		case "${ANSWER:0:1}" in
 		  y|Y )  echo "Yes" ;;
-		    * )  echo "No" ; PROMPTING=""; cleanup 1 ;;
+		    * )  echo "No" ; PROMPTING=""; return 1 ;;
 		esac
 		PROMPTING=""
 		YES="-y" # From now, no prompting
 	fi
 
 	# Make a backup of the existing VDO yaml configuration file
-	test -e "$VDO_CONFIG" && dry cp -a "$VDO_CONFIG" "${VDO_CONFIG}.backup"
+	[ -e "$VDO_CONFIG" ] && dry cp -a "$VDO_CONFIG" "${VDO_CONFIG}.backup"
 
+	DEVICE=$FOUND
 	case "$DM_UUID" in
 		LVM-*) convert_lv_ "$vdo_logicalSize" ;;
 		*)     convert_non_lv_ "$vdo_logicalSize" ;;
@@ -608,9 +685,9 @@ EOF
 # start point of this script
 # - parsing parameters
 #############################
-trap "cleanup 2" 2
+trap "cleanup" "${SIGNALS[@]}"
 
-test "$#" -eq 0 && tool_usage
+[ "$#" -eq 0 ] && tool_usage
 
 while [ "$#" -ne 0 ]
 do
@@ -621,19 +698,17 @@ do
 	  "-n"|"--name"   ) shift; NAME=$1 ;;
 	  "-v"|"--verbose") VERB="--verbose" ;;
 	  "-y"|"--yes"    ) YES="-y" ;;
-	  "--abort-after-vdo-convert" ) ABORT_AFTER_VDO_CONVERT=1; USE_VDO_DM_SNAPSHOT=0 ;; # For testing only
-	  "--dry-run"     ) DRY="1" ; VERB="-v" ;;
-	  "--no-snapshot" ) USE_VDO_DM_SNAPSHOT=0 ;;
-	  "--uuid-prefix" ) shift; DM_UUID_PREFIX=$1 ;; # For testing only
-	  "--vdo-config"  ) shift; VDO_CONFIG=$1 ; VDOCONF="-f $VDO_CONFIG" ;;
-	  "-*") error "Wrong argument \"$1\". (see: $TOOL --help)" ;;
+	  "--abort-after-vdo-convert"|"--abortaftervdoconvert" ) ABORT_AFTER_VDO_CONVERT=1; USE_VDO_DM_SNAPSHOT= ;; # For testing only
+	  "--dry-run"|"--dryrun" ) DRY="1" ; VERB="-v" ;;
+	  "--no-snapshot"|"--nosnapshot" ) USE_VDO_DM_SNAPSHOT= ;;
+	  "--uuid-prefix"|"--uuidprefix" ) shift; DM_UUID_PREFIX=$1 ;; # For testing only
+	  "--vdo-config"|"--vdoconfig" ) shift; VDO_CONFIG=$1 ; VDOCONF="-f $VDO_CONFIG" ;;
+	  -* ) error "Wrong argument \"$1\". (see: $TOOL --help)" ;;
 	  *) DEVICE=$1 ;;  # device name does not start with '-'
 	esac
 	shift
 done
 
-test -n "$DEVICE" || error "Device name is not specified. (see: $TOOL --help)"
+[ -n "$DEVICE" ] || error "Device name is not specified. (see: $TOOL --help)"
 
 convert2lvm_
-
-cleanup 0
-- 
2.41.0

