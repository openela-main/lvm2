From 3603348e5035d58aa6c458cdf273760be9af7462 Mon Sep 17 00:00:00 2001
From: Zdenek Kabelac <zkabelac@redhat.com>
Date: Fri, 23 Jun 2023 18:01:32 +0200
Subject: [PATCH 109/115] lvm_import_vdo: correct the converted virtual size

Ensure the volume after conversion has the properly aligned size to the
volume group extent size. This would be visible when using virtual size,
that cannot be divided by extent size.

Before the user had to manually adjust the size after conversion to get
access to all data stored on VDO volume.

(cherry picked from commit 657dde6208ddc8172b7d0e1466751046c8ddaeaa)
---
 scripts/lvm_import_vdo.sh | 10 ++++++++--
 1 file changed, 8 insertions(+), 2 deletions(-)

diff --git a/scripts/lvm_import_vdo.sh b/scripts/lvm_import_vdo.sh
index bae4b52d1..13197c6fb 100755
--- a/scripts/lvm_import_vdo.sh
+++ b/scripts/lvm_import_vdo.sh
@@ -357,6 +357,7 @@ convert_lv_() {
 # For best use the latest version of  vdoprepareforlvm tool is required.
 convert_non_lv_() {
 	local vdo_logicalSize=$1
+	local vdo_logicalSizeRounded
 	local extent_size
 	local output
 	local pvfree
@@ -417,7 +418,7 @@ convert_non_lv_() {
 	# Round virtual size to the LOWER size expressed in extent units.
 	# lvm is parsing VDO metadata and can read real full size and use it instead of this smaller value.
 	# To precisely byte-synchronize the size of VDO LV, user can lvresize such VDO LV later.
-	vdo_logicalSize=$(( ( vdo_logicalSize / extent_size ) * extent_size ))
+	vdo_logicalSizeRounded=$(( ( vdo_logicalSize / extent_size ) * extent_size ))
 
 	verbose "Creating VG \"${NAME%/*}\" with extent size $extent_size KiB."
 	dry "$LVM" vgcreate $YES $VERB --devices "$devices" -s "${extent_size}k" "$VGNAME" "$devices" || {
@@ -428,7 +429,12 @@ convert_non_lv_() {
 	dry "$LVM" lvcreate -Zn -Wn -an $YES $VERB --devices "$devices" -l100%VG -n "${LVNAME}_vpool" "$VGNAME" "$devices"
 
 	verbose "Converting to VDO pool."
-	dry "$LVM" lvconvert $YES $VERB $FORCE --devices "$devices" --config "$VDO_ALLOCATION_PARAMS" -Zn -V "${vdo_logicalSize}k" -n "$LVNAME" --type vdo-pool "$VGNAME/${LVNAME}_vpool"
+	dry "$LVM" lvconvert $YES $VERB $FORCE --devices "$devices" --config "$VDO_ALLOCATION_PARAMS" -Zn -V "${vdo_logicalSizeRounded}k" -n "$LVNAME" --type vdo-pool "$VGNAME/${LVNAME}_vpool"
+	if [ "$vdo_logicalSizeRounded" -lt "$vdo_logicalSize" ] ; then
+		# need to extend virtal size to be covering all the converted area
+		# let lvm2 to round to the proper virtual size of VDO LV
+		dry "$LVM" lvextend $YES $VERB --fs ignore --devices "$devices" -L "$vdo_logicalSize"k "$VGNAME/$LVNAME"
+	fi
 
 	dry "$LVM" vgchange -an $VERB $FORCE --devices "$devices" "$VGNAME"
 
-- 
2.41.0

